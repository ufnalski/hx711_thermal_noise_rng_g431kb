# Thermal noise based random number generator (STM32G431KB)
An STM32 HAL demo of a true random number generation achieved by tapping into thermal noise of resistors, opamps and ADCs.

![HX711 RNG in action](/Assets/Images/hx711_rng_in_action.jpg)

[The Geiger counter](https://github.com/ufnalski/geiger_muller_tube_true_randomness_g474re), [the lavarand](https://github.com/ufnalski/ov2640_lavarand_h743zi2) or [the automatic dice roller](https://github.com/ufnalski/pixy2_dice_roller_h503rb) are not very practical concepts as far as integrating them into a uC is envisaged to get a built-in RNG peripheral. On the other hand, thermal noise is very practical source of entropy in uC. Let us experiment with that concept by building an external to a uC RNG, which, however, exploits a phenomenon that makes it practical to be integrated into a uC.

[Wikipedia](https://en.wikipedia.org/wiki/Johnson%E2%80%93Nyquist_noise):
> Johnson-Nyquist noise (thermal noise, Johnson noise, or Nyquist noise) is the electronic noise generated by the thermal agitation of the charge carriers (usually the electrons) inside an electrical conductor at equilibrium, which happens regardless of any applied voltage. Thermal noise is present in all electrical circuits, and in sensitive electronic equipment (such as radio receivers) can drown out weak signals, and can be the limiting factor on sensitivity of electrical measuring instruments.

This electronic noise is usually something we want to get rid off (precisely speaking, to reduce) in our circuits. However, there are scenarios in which such a noise can be exploited to our benefit. One of them is obtaining truly/hardware random numbers. What we need is to "measure" that noise, i.e. to get a digital signal effectively affected by the thermal noise. Check e.g. ["A true random number generator that utilizes thermal noise in a programmable system-on-chip (PSoC)"](https://onlinelibrary.wiley.com/doi/10.1002/cta.3046) by Shunsuke Matsuoka, Shuichi Ichikawa, and Naoki Fujieda for some calculations. We are in the realm of uV, therefore an opamp and a high-resolution ADC will be helpful here. And the more noisy they are themselves, the better, so you don't have to go for high-end devices.

[HX711](https://github.com/ufnalski/hx711_non_blocking_spi_g431kb) suits our experiment as it offers the 24-bit resolution and the 128x PGA (programmable gain amplifier[^1]). The evaluation board can be easily bought under $2. Note the filtering capacitor removed from the board - the more noisy measurement, the better. Select 80 SPS output data rate to reduce waiting time for 1 million bits for NIST testing.

[^1]: [Manual Gain Setting For Op Amp using Digital Potentiometer](https://www.youtube.com/watch?v=XdbXkEkS0mc) (Gadget Reboot)

![HX711 removed capacitor](/Assets/Images/hx711_removed_capacitor.jpg)

My setup includes two grounded 4 MOhm resistors (4x 1 Mohm) connected to the differential inputs INA- and INA+ of the HX711 chip. The channel A is chosen to take advantage of its 128x PGA. The 1 W resistor is there to make the adjacent resistors more noisy - the variance goes up with the temperature.

![HX711 bell-shaped curve](/Assets/Images/h711_bell_curve_high_temp.JPG)

> [!TIP]
> Select carbon composition or thick film resistors to increase thermal noise[^2].

> [!TIP]
> If you are interested in more scenarios in which making a system less deterministic[^3] can be beneficial, check e.g. spread-spectrum frequency dithering[^4][^5][^6][^7].

![STM32U5 PWM dithering](/Assets/Images/stm32u5_pwm_dithering.png)

[^2]: [Resistor Noise](https://eepower.com/resistor-guide/resistor-fundamentals/resistor-noise/)
[^3]: Yeah, I know, there are just two categories, deterministic XOR non-deterministic (stochastic), an trying to gradate them is a risky business :no_entry: And yes, I know that non-deterministic and stochastic are not synonyms but in mathematics and computer science they are largely synonymous terms.
[^4]: [Utilizing Dual-Random Spread Spectrum to improve EMI performance](https://www.ti.com/video/6237230206001) (Texas Instruments)
[^5]: [Spread spectrum](https://en.wikipedia.org/wiki/Spread_spectrum) (Wikipedia)
[^6]: [Demonstration firmware for PWM resolution enhancement through dithering technique software expansion for STM32Cube (AN4507)](https://www.st.com/en/embedded-software/x-cube-pwm-dithr.html) (ST)
[^7]: [RM0456: Reference manual: STM32U5 Series Arm-based 32-bit MCUs](https://www.st.com/resource/en/reference_manual/rm0456-stm32u5-series-armbased-32bit-mcus-stmicroelectronics.pdf) (search for: dithering)

# Missing files?
Don't worry :slightly_smiling_face: Just hit Alt-K to generate /Drivers/CMCIS/ and /Drivers/STM32G4xx_HAL_Driver/ based on the .ioc file. After a couple of seconds your project will be ready for building.

# Software tools
* A serial monitor such as [YAT](https://sourceforge.net/projects/y-a-terminal/), [RealTerm](https://sourceforge.net/projects/realterm/) or [Tabby](https://tabby.sh/).

# Exemplary hardware
* [USB to UART converter](https://www.waveshare.com/ch343-usb-uart-board.htm) (Waveshare) - just for the convenience of having two separate COM ports: one for debugging messages and the other one for streaming random bits to the computer for their statistical evaluation.

# Entropy extractor 1
In this example I deployed probably the easiest randomness extractor in the form of a parity bit calculator:
```c
if (__builtin_parity(adc_reading))
	{
		uint8_t bit1 = '1';
		HAL_UART_Transmit(RNG_STREAM_UART, &bit1, 1, 10);
	}
	else
	{
		uint8_t bit0 = '0';
		HAL_UART_Transmit(RNG_STREAM_UART, &bit0, 1, 10);
	}
```
It's probably a waste of entropy harvested by the 24-bit ADC augmented with the 128x PGA. Sorry for that. Do it better!

![Entropy extractor 1 performance](/Assets/Images/thermal_noise_nist_tests.JPG)

# RDD and RFC
Writing a README.md helps me a lot in finding new ideas to be put into the test. The "RFC" (request for comments)[^8] process and the readme driven development (RDD)[^9] resonate with me strongly. You should definitely try them even in your hobby projects. I've just realized that I should implement one more entropy extractor (more efficient one) and leave it for you to test. Fingers crossed :slightly_smiling_face:

[^8]: [Rust RFCs - RFC Book - Active RFC List](https://github.com/rust-lang/rfcs) (GitHub)
[^9]: [Readme Driven Development](https://gist.github.com/stefanbirkner/835b7d0c498b4026f65a) (GitHub) and [Readme Driven Development (RDD)](https://www.agilelonestar.com/knowledge-base/rdd) (LoneStar Agile)

# Entropy extractor 2 (potentially too biased - use von Neumann's strategy to get an unbiased bitstream)
```c
for (uint8_t i = 0; i < NUMBER_OF_LSB; i++)
	{
	if (((adc_reading >> i) & 0x00000001) == 1)
		{
			uint8_t bit1 = '1';
		    HAL_UART_Transmit(RNG_STREAM_UART, &bit1, 1, 10);
		}
		else
		{
			uint8_t bit0 = '0';
			HAL_UART_Transmit(RNG_STREAM_UART, &bit0, 1, 10);
		}
	}
```
My preliminary tests for ```#define NUMBER_OF_LSB 4``` give some hope. However, the 4-bit approach consistently fails the runs test. Maybe I should try another test suite implementation[^10][^11].

[^10]: [NIST test suite with biased PRNG](https://crypto.stackexchange.com/questions/85978/nist-test-suite-with-biased-prng)
[^11]: [sp800_22_tests](https://github.com/dj-on-github/sp800_22_tests) (David Johnston)

# What next?
Try to harness electromagnetic pollution around us. Connect an antenna to one of the resistors. For starters use a 50+ cm long wire flapping in the breeze. Note orders of magnitude higher ```HISTOGRAM_OFFSET``` and ```HISTOGRAM_BAR_WIDTH``` presets for this scenario. Check the distribution. Still Gaussian (bell-shaped) one? No? Why? Experiment with bringing the antenna closer to an electronic equipment powered from the mains. How do your actions affect randomness test results? Is it always beneficial to seek a signal characterized by a higher variance? Let me invite you for a thought experiment. Consider a discrete random variable that can take only two values (two distinct ADC readings). You can get any variance you want by separating these values with a high enough distance (remember, it's a thought experiment). And now apply the first of the above-mentioned entropy extractors. Is it bound to fail? Probably the safest answer is that it depends :slightly_smiling_face: But it depends on what?

# Call for action
Create your own [home laboratory/workshop/garage](http://ufnalski.edu.pl/control_engineering_for_hobbyists/2024_dzien_otwarty_we/Dzien_Otwarty_WE_2024_Control_Engineering_for_Hobbyists.pdf)! Get inspired by [ControllersTech](https://www.youtube.com/@ControllersTech), [DroneBot Workshop](https://www.youtube.com/@Dronebotworkshop), [Andreas Spiess](https://www.youtube.com/@AndreasSpiess), [GreatScott!](https://www.youtube.com/@greatscottlab), [ElectroBOOM](https://www.youtube.com/@ElectroBOOM), [Phil's Lab](https://www.youtube.com/@PhilsLab), [atomic14](https://www.youtube.com/@atomic14), [That Project](https://www.youtube.com/@ThatProject), [Paul McWhorter](https://www.youtube.com/@paulmcwhorter), [Max Imagination](https://www.youtube.com/@MaxImagination), and many other professional hobbyists sharing their awesome projects and tutorials! Shout-out/kudos to all of them!

> [!WARNING]
> Mathematics, electronics and embedded systems - do try this at home :exclamation:

190+ challenges to start from: [Control Engineering for Hobbyists at the Warsaw University of Technology](http://ufnalski.edu.pl/control_engineering_for_hobbyists/Control_Engineering_for_Hobbyists_list_of_challenges.pdf).

Stay tuned!
